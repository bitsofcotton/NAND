load Meta.s
# referring some mathematic results, 2 term operators.

type Int[int bits] : Object
  def int  : Int[bits / 2]
  def dint : Int[bits]
  def lsb  : 0
  def msb  : bits - 1
  e0 : int
  e1 : int
  friend op Int  ()
    return Int(e0)
  friend op int  ()
    return e0
  friend op bool ()
    return bool(e0) | bool(e1)
  fn ctor(d : def):
    zero : static const dint(0)
    ten  : static const dint(10)
    this = zero
    for x in d:
      this *= ten
      this += dint(x)
    return this
  fn ctor(d : (Int|const Int))
    
  fn  []  (const Int) : bool
  fn  []  (const Int) const : bool
  fn  []  (const Int, const Int) : dint
  fn  []  (const Int, const Int) const : dint
  fn  ~   () const : int
    e0 = ~ e0
    e1 = ~ e1
    return this
  def zorn() : dint
    ++ e0
    if(! e0)
      ++ e1
    return this
  fn  --  () : dint
    if(! e0)
      -- e1
    -- e0
    return this
  fn  *   (src : (dint | const dint)) const : dint
    let res : dint(0)
    for bit in src:
      if(bit):
        res += this << bit.idx
    return res
  fn  **  (src : (dint | const dint)) const : dint
    res  : dint(1)
    work : auto(this)
    for bit in src:
      if(bit):
        res *= work
      work *= work
    return res
  fn  /   (const dint) const : dint
  fn  <<  (const dInt) const : dint
  fn  >>  (const dInt) const : dint
  def less(src : (dint | const dint)) const : bool
    return (this - src)[msb]
  fn !=  (const dint) const : bool
    return ! (this == src)
  fn ==  (src : (dint | const dint)) const : bool
    return bool(this ^ src)
  fn =   (dint)             : int
  fn =   (const dint)       : int
  fn +=  (const dint)       : int
    ## assembler??
  fn &=  (src : (dint | const dint)) : int
    e0 &= src.e0
    e1 &= src.e1
    return this
  fn |=  (src : (dint | const dint)) : int
    e0 |= src.e0
    e1 |= src.e1
    return this
  fn ^=  (src : (dint | const dint)) : int
    e0 ^= src.e0
    e1 ^= src.e1
    return this

type ParaInt[def type, Int wbits, Int pbits]
  def int   : ParaInt[type, wbits, pbits]
  def bint  : type
  _flat : Int[wbits]
  fn  ctor()
  fn  ctor(def)
  fn  ctor(type)
  fn  ctor(type, fn)
  fn  ctor(const bint)
  fn  ctor(const bint, fn)
  fn  dtor()
  fn  dopara(fn)
  fn  []  (const Int) : bool
  fn  []  (const Int) const : bool
  fn  []  (const Int, const Int) : bool
  fn  []  (const Int, const Int) const : bool
  fn  !   () const : bool
  fn  ~   () const : int
  fn  ++  ()     : int
  fn  ++  (void) : int
  fn  --  ()     : int
  fn  --  (void) : int
  fn  -   ()     const : int
  fn  *   (const int) const : int
  fn  **  (const int) const : int
  fn  /   (const int) const : int
  fn  %   (const int) const : int
  fn  +   (const int) const : int
  fn  -   (const int) const : int
  fn  <<  (const Int) const : int
  fn  >>  (const Int) const : int
  fn  <   (const int) const : bool
  fn  <=  (const int) const : bool
  fn  >   (const int) const : bool
  fn  >=  (const int) const : bool
  fn  ==  (const int) const : bool
  fn  !=  (const int) const : bool
  fn  &   (const int) const : int
  fn  ^   (const int) const : int
  fn  |   (const int) const : int
  fn  &&  (const int) const : bool
  fn  ||  (const int) const : bool
  fn  =   (int)       : int
  fn  =   (const int) : int
  fn  +=  (const int) : int
  fn  -=  (const int) : int
  fn  *=  (const int) : int
  fn  **= (const int) : int
  fn  /=  (const int) : int
  fn  %=  (const int) : int
  fn  /=  (const int) : int
  fn  <<= (const Int) : int
  fn  >>= (const Int) : int
  fn  &=  (const int) : int
  fn  |=  (const int) : int

type Signed[def type] : type
  def int : Signed[type]
  fn  ctor()
  fn  ctor(def)
  fn  ctor(type)
  fn  ctor(const type)
  fn  ctor(int)
  fn  ctor(const int)
  fn  dtor()
  fn  <   (const int) const : bool
  fn  <=  (const int) const : bool
  fn  >   (const int) const : bool
  fn  >=  (const int) const : bool

type pZ[def type, type z] : type
  def pz : pz[type, z]
  fn leave() : pz
    return this %= z

type Band[def type] : Complex[type]
  fn ctor()
  fn dtor()

fn gcd[def type](const type, const type) : type
fn lcm[def type](const type, const type) : type
fn factor2[def type](const type) : type
fn max[def type](const type, const type) : type
fn min[def type](const type, const type) : type
fn abs(const Signed) : type

// Solve ax + by = c in Z, a, b, c are const.
fn eucleidos[def type](type, type, const type, const type, const type) : void

type Float[Int mantissa, Int exponent] : Object
  def float : Float[mantissa, exponent]
  def intm  : Int[mantissa]
  def intw  : Int[mantissa * Int(2)]
  def inte  : Int[exponent]
  def INF   : const int("0x1")
  def NaN   : const int("0x2")
  def SIGN  : const int("0x4")
  def WORK  : const int("0x8")
  _m    : intm
  _e    : inte
  _flag : int
  fn  ctor()
  fn  ctor(def)
  fn  dtor()
  fn  leave : float
  fn  ! () const : bool
  fn  - () const : float
  fn  *  (const float) const : float
  fn  ** (const float) const : float
  fn  /  (const float) const : float
  fn  %  (const float) const : float
  fn  +  (const float) const : float
  fn  -  (const float) const : float
  fn  <  (const float) const : bool
  fn  <= (const float) const : bool
  fn  >  (const float) const : bool
  fn  >= (const float) const : bool
  fn  == (const float) const : bool
  fn  != (const float) const : bool
  fn  =  (float)        : float
  fn  =  (const float)  : float
  fn  += (const float)  : float
  fn  -= (const float)  : float
  fn  *= (const float)  : float
  fn  **= (const float) : float
  fn  /= (const float)  : float
  fn  %= (const float)  : float
  friend Int() const

type WFloat[def float_t] : Object
  def float : WFloat[float_t]
  _f0 : float_t
  _f1 : float_t
  fn  ctor()
  fn  ctor(def)
  fn  ctor(float_t)
  fn  ctor(float)
  fn  dtor()
  friend float() const
  fn  !  () const : bool
  fn  -  () const : float
  fn  *  (const float) const : float
  fn  ** (const float) const : float
  fn  /  (const float) const : float
  fn  %  (const float) const : float
  fn  +  (const float) const : float
  fn  -  (const float) const : float
  fn  <  (const float) const : bool
  fn  <= (const float) const : bool
  fn  >  (const float) const : bool
  fn  >= (const float) const : bool
  fn  == (const float) const : bool
  fn  != (const float) const : bool
  fn  =  (const float) : float
  fn  += (const float) : float
  fn  -= (const float) : float
  fn  *= (const float) : float
  fn  **= (const float) : float
  fn  /= (const float) : float
  fn  %= (const float) : float

type Fraction[def type] : Object
  def fraction : Fraction[type]
  _sign : bool
  _n    : type
  _d    : type
  fn  ctor()
  fn  ctor(type, type)
  fn  ctor(const type, const type)
  fn  dtor()
  fn  ** (const fraction) const : fraction
  fn  <  (const fraction) const : bool
  fn  <= (const fraction) const : bool
  fn  >  (const fraction) const : bool
  fn  >= (const fraction) const : bool
  fn  != (const fraction) const : bool
  fn  =  (fraction)       : fraction
  fn  =  (const fraction) : fraction
  fn  += (const fraction) : fraction
  fn  *= (const fraction) : fraction
  fn  /= (const fraction) : fraction

fn floor[def type](type) : type
fn ceil[def type](type)  : type
fn isnan[def type](type) : bool
fn isinf[def type](type) :bool

# finite gropus, and make new finite series from them with some method.
# Cryption bases
# Hash bases
# Leed solomon
# Hamming
# Vitavi
# Huge...

type Equation : BNF
type Logic : Equation

# transcendal op on equation should be in generic programming compatible form in this
fn bothside[def type](type, type, type) : type
fn newton[def type, def f](type) : type
fn superGeometry[def type, fn da(type) : type, fn db(type) : type, def f] : type
fn sqrt[def type](type) : type
fn pi[def type](type)   : type
fn exp[def type](type)  : type
fn log[def type](type)  : type
fn sin[def type](type)  : type
fn cos[def type](type)  : type
fn tan[def type](type)  : type
fn asin[def type](type) : type
fn acos[def type](type) : type
fn atan[def type](type) : type
fn atan2[def type](type, type) : type
fn exp(Complex)  : Complex
fn log(Complex)  : Complex
fn sin(Complex)  : Complex
fn cos(Complex)  : Complex
fn tan(Complex)  : Complex
fn csc(Complex)  : Complex
fn sec(Complex)  : Complex
fn cot(Complex)  : Complex
fn asin(Complex) : Complex
fn acos(Complex) : Complex
fn atan(Complex) : Complex
fn sinh(Complex) : Complex
fn cosh(Complex) : Complex
fn tanh(Complex) : Complex
fn Li2(Complex)  : Complex
fn SolveSeries[def type](fn coeff(type) : type, const type x) : type
fn SolveSeries[def type](const Array[type] coeff, const type x) : type
fn InvertSeries[def type](const Array[type] coeff, const type y)
fn Melin[def type](const Array[type] coeff, const type y)

