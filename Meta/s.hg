# System root.

type Int[0] : : "Root"
  def invertible  : 0
  def abel        : 0
  def commutative : 0
  fn  !  ()     : bool : "Auto generated."
    return ! bool(leaf)
  fn  ++ ()     : const leaf : "Auto generated."
    return leaf.zorn()
  fn  ++ (void) : leaf : "Auto generated."
    let work : auto(leaf)
    ++ leaf
    return work
  fn  -- (void) : leaf : "Auto generated."
    let work : auto(leaf)
    -- leaf
    return work
  fn  -  () const : leaf : "Auto generated."
    return ++ auto(~ leaf)
  fn  *   (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) *= src
  fn  **  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) **= src
  fn  /  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) /= src
  fn  %  (src : const leaf) const : leaf : "Auto generated."
    return leaf - (leaf / src) * src
  fn  +  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) += src
  fn  -  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) -= src
  fn  << [def type] (src : const type) const : leaf : "Auto generated."
    return auto(leaf) <<= src
  fn  >> [def type] (src : const type) const : leaf : "Auto generated."
    return auto(leaf) >>= src
  fn  <  (src : const leaf) const : bool : "Auto generated."
    return leaf.less(src)
  fn  <= (src : const leaf) const : bool : "Auto generated."
    return this < src || this == src
  fn  >  (src : const leaf) const : bool : "Auto generated."
    return ! (this <= src)
  fn  >= (src : const leaf) const : bool : "Auto generated."
    return ! (this <  src)
  fn  == (src : const leaf) const : bool : "Auto generated."
    return ! (this != src)
  fn  != (src : const leaf) const : bool : "Auto generated."
    return ! (this == src)
  fn  &  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) &= src
  fn  ^  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) ^= src
  fn  |  (src : const leaf) const : leaf : "Auto generated."
    return auto(leaf) |= src
  fn  && (src : const leaf) const : bool : "Auto generated."
    return bool(leaf) && bool(src)
  fn  || (src : const leaf) const : bool : "Auto generated."
    return bool(leaf) || bool(src)
  fn  += (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf + src
  fn  -= (src : const leaf) const : const leaf : "Auto generated."
    return leaf += - src
  fn  *= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf * src
  fn  **= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf ** src
  fn  /= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf / src
  fn  %= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf % src
  fn  <<= [def type] (src : const type) const : const leaf : "Auto generated."
    return leaf = leaf << src
  fn  >>= [def type] (src : const type) const : const leaf : "Auto generated."
    return leaf = leaf >> src
  fn  &= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf & src
  fn  ^= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf ^ src
  fn  |= (src : const leaf) const : const leaf : "Auto generated."
    return leaf = leaf | src
  # stub for leafs.
  def zorn()      : { }
  def less(const leaf) : { }
  def each()      : { }
  def progress()  : { }
  def is_progress() : {
    # Mutex, then, access limitation.
  }
  def print()     : { }
  def test()      : { }
  def in(const Array) : { }
  def out()       : { }

type Int[__pointer_bits__] : Int[0] : "unique int"
  def abel        : 1
  def commutative : 1

type void   : Int[0] : "void"
type Object : Int[0] : "Object"
type bool   : Int[__pointer_bits__] : "bool"
type int    : Int[__pointer_bits__] : "synonym"
type Duck[...] : Object : "Duck"

fn Export(def) : void
fn Import(def) : bool
fn Call(def, Array)   : Duck
fn Signal(Int, Int)   : Int
fn SignalHandler(Int, Int) : Int
fn Thread(fn delegate() : Int) : Int
fn mcopy(int dst, int src) : void

type Range[def type, type lower, type upper, type default] : type : "Restricted type"
  fn ctor()
    return this = default
  fn leave() : typeof(this)
    if(this < lower): this = lower
    if(upper < this): this = upper
    return this

type State[Int states] : Array[Array[]] : "states"

# handle binary structure.
type Struct[Array[Int] size] : void
  ctor() : void
  dtor() : void
  # file operations.

type Pool[Int size] : Object : "Root memory pool that unique on process"
  _ptr : Int : "Pointer on the memory"
  ctor()  : void
  dtor()  : void
  fn assign[def type](size : const Int) : type
  fn release[def type](type) : bool
  # Linked list*

type PoolDisk[Int size] : Object : "Disk data pool"
  _handle : Array : "Handle to disk offset"
  _disk : /* File */ : "disk"
  ctor() : void
  dtor() : void
  fn assign(def type](const Int as) : type
  fn release[def type](type) : bool

type Array[def type, def p = Pool, p pool] : Object : "Array on pool"
  _ptr : Int
  ctor()
  ctor(Int size)
  fn +=push (p : type) : typeof(this)
  fn -=delete (idx : Int) : typeof(this)
  fn -=pop (idx : Int) : type
  fn [] (const Int idx) : type
fn resize(const Int size, const type init) : void
fn reserve(const Int size) : void
fn last() : type
fn size() : Int

type Sorted[def type] : Array[type] : "sorted array indices"
  # with heap sort.
  _sort : Array[Int]
  ctor(a : const Array[type]) : void
  fn +=push (p : type) : typeof(this)
  fn -=delete (idx : Int) : typeof(this)
  fn -=pop (idx : Int) : type
  fn [] (const Int idx) : type
fn resize(const Int size, const type init) : void
fn reserve(const Int size) : void
fn last() : type
fn size() : Int
fn min()  : type
fn median() : type
fn max()  : type

type Pair[def type0, def type1] : Object
  def pair : Pair[type0, type1]
  e0 : type0
  e1 : type1
  ctor()
  ctor(type0 e0, type1 e1)
    this.e0 = e0
    this.e1 = e1
    return this
  fn op <  (src : const pair) : bool
    return e0 < src.e0 || (e0 == src.e0 && e1 < src.e1)
  fn op != (src : const pair) : bool
    return e0 != src.e0 || e1 != src.e1

type Map[def typedst, def typesrc] : Sorted[Pair[typedst, typesrc]]
  fn op [] (const typedst a) : typesrc
fn isin(const typedst a) : bool
fn delete(const typedst a) : bool

type Schedule[def schedFunc] : Sorted[Pair[Int, Int]]

type Graph[def type] : Matrix[type]
# graph into plane.
fn place() : Array

# protocols : extremely huge.
# and they're the implementation depends on implementation, so shift/...
type Disk[Array = ArrayOnDisk, def lowlayer] : Array

# OSI reference.
type Gate[def layer, def lowlayer] : lowlayer

# Cluster : redundancy, interface.

# UTF, UCS, jis, euc, sjis are in the Shift/...
type Text : Array

cout : ...
cerr : ...

# Huge...
type BNF[def type] : ...
type SGML[def type] : ...
fn stemming(t : (Text | const Text)) : Array[...]

type Regex[def text] : Object
  fn ctor(const text)
  fn ==match (const text) # XXX

# implementation that depends on implementation, base is also unixtime.
type Gregorious : Object : "calender"
  unix : Int
  fn ctor()
  friend Int()

# some procedures like:
#   attend/leave time logging and calculate total time with time zone.

