using Meta.s
using Meta.2
using Meta.n
# graphics, geometry.

type Glay[def type] : type
type RGB[def type] : Object
  let r : type
  let g : type
  let b : type
  fn ctor(Glay[type] src)
    r = type(src)
    g = type(src)
    b = type(src)
    return this
  friend Glay()
    # not optimal, we should refer color space in wikipedia.
    return (r + g + b) / type(3)
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  def zorn() : this
  def less() : bool
  def ensure() : this
  # ...

type RGBA[def type] : Quarternion[type]
  def rgba : Quarternion[type]
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  def zorn() : this
  def less() : bool
  def ensure() : this

type HSV[def type] : Object
  let h : type
  let s : type
  let v : type
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  def zorn() : this
  def less() : bool
  def ensure() : this

type HSB<def type> : Object
  let h : type
  let s : type
  let b : type
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  def zorn() : this
  def less() : bool
  def ensure() : this

type Lab<def type> : Object
  let l : type
  let a : type
  let b : type
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  def zorn() : this
  def less() : bool
  def ensure() : this

type ColorDigital[def type] : Vector[type]
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  def zorn() : this
  def less() : bool
  def ensure() : this

type ColorAnalogue[def type, fn func] : Object
  fn  op -  () : this
  fn  op != () : this
  fn  op += () : this
  fn  op ColorDigital[type]() : ColorDigital[type]()
  def zorn() : this
  def less() : bool
  def ensure() : this

type Texture[def color] : Matrix[color]
  fn  ctor(const Complex[Int]) : void
  fn  dtor() : void
  fn  load!(xywh : , ** File **) : Texture
  fn  store!(xywh : , t : Texture) : Texture
  fn  clear!(xywh : , c : color) : Texture
  fn  point!(xy : Complex, c : color) : Texture
  fn  line!(xy : Complex, c : color) : Texture
  # make pattern
  fn  plot!(e : Equaion, xywh) : Texture
  fn  splot!(e : Equation, xyzwhz) : Texture
  fn  maze!(wh) : Texture
  # friend on them???
  fn  tilt(mesh : , xywh) : Texture
  fn  poincare!(e : Equation, Matrix) : Texture
  friend SVG(t : Texture) : SVG
  # illust...
  # font is the implementation depends implementation.
  fn  renderFont[type type]() : Texture

type PlayMovie[def color, def driver] : Texture[color]
  fn load!() : void
  fn play!() : Texture

# Widgets: dom xml base. referes w3c minimal set. huge...

# geometry
type geomIndex : Equation
fn ker(e : Equation) : Int
fn dim(e : Equation) : Int
fn coker(e : Equation) : Int
  return dim(e) - ker(e)
fn jacobi(e : Equation) : Matrix
  return
fn eigens(e : Equation) : Vector
  return
fn factor(e : Equation) : Array[Equation]
  return
fn differentialForm(e : Equation) : Equation
  return
fn solve(e : Equation) : Equation
fn approximate(e : Equation, f : Equation) : Equation
fn poincare(e: Equation, f : Equation) : Equation
# fn render(e : Equation) : Vector[Vector ...]

type SoundBuffer : Vector
type SoundGeom
type Instruments

