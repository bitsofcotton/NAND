using Meta.nterm

# Wait, pipe, etc...

# entity is in Shift/...
type Chip : ...
  fn ctor() : void
  fn dtor() : void
  # emulation, control, describe as higher order implementation.
  # errata.

type Status[] : ...
  fn ctor(json : JSON) : void
  fn dtor() : void
  fn next!(s : String) : Status

# entity is in Shift/...
type Mnemonic : ...
  fn ctor() : void
  fn dtor() : void
  fn equal() : void

fn optimizeFlow(v : Vector[Mnemonic]) : Vector[Mnemonic]
fn compile(v : Vector[Mnemonic]) : Vector[Mnemonic]

type Runner : 
  fn ctor() : void
  fn dtor() : void
  let c2r : Vector[Pair[Mnemonic, Mnemonic]]

type Perceptron[def type] : Matrix[type]
  def vec : Vector[type]
  fn ctor() : void
  fn dtor() : void
  fn in(const vec, const vec) : bool
  fn in(const vec) : bool
  fn out(const vec) : vec

type Optron[def type] : Matrix[type]
  fn ctor() : void
  fn dtor() : void
  fn in(const vec, const vec) : bool
  fn in(const vec) : bool
  fn out(const vec) : vec

type Delayron[def type] : Array
  fn ctor() : void
  fn dtor() : void
  fn in(const vec, const vec) : bool
  fn in(const vec) : bool
  fn out(const vec) : vec

type BlockDiagram[def type] : Array[Perceptron[type]]
  def vec : Vector[type]
  fn ctor(const Matrix[Int] d) : void
  fn dtor() : void
  fn in(const vec, const vec) : bool
  fn in(const vec) : bool
  fn out(const vec) : vec

