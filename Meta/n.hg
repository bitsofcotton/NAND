using Meta.s

type Vector[def type, def index, def Array = Array]
  def vector : Vector[type, index]
  e : Array[type]
  fn  ctor(const index, const type e0)
  fn  init(fn ier(idx : index, entity : type) : void) : vector
  fn  [] (const index)        : type
  fn  [] (const index)  const : const type
  fn  [] (const index, const index)        : vector
  fn  [] (const index, const index)  const : const vector
  fn  friend bool
  fn  -  ()             const : vector
  fn  *dot (const vector) const : type
  fn  != (const vector) const : bool
  fn  =  (vector)       : vector
  fn  =  (const vector) : vector
  fn  += (const vector) : vector
  fn  -= (const vector) : vector
  fn  *=  (const type)   : vector
  fn  **= (const type)   : vector
  fn  /=  (const type)   : vector
  fn  %=  (const type)   : vector
  def less() : bool

type Matrix[def type, def index0, def Array = Array]
  def matrix : Matrix[type, index0]
  def vector : Vector[type, index0]
  def index  : Complex[index0]
  _e : Array[vector]
  fn  ctor(const index, const type e0) : void
  fn  []row(const index0) : vector
  fn  []row(const index0) const : const vector
  fn  []setCol(const index0, const vector) : void
  fn  []col(const index0) const : const vector
  fn  [] (const index)       : type
  fn  [] (const index) const : const type
  fn  [] (const index, const index)       : type
  fn  [] (const index, const index) const : const type
  fn  !  ()             const : bool
  fn  -  ()             const : matrix
  fn  *  (const vector) const : vector
  fn  *  (const matrix) const : matrix
  fn  ** (const type)   const : matrix
  fn  <d  (const matrix) const : bool
  fn  != (const vector) const : bool
  fn  =  (matrix)       : matrix
  fn  =  (const matrix) : matrix
  fn  += (const matrix) : matrix
  fn  -= (const matrix) : matrix
  fn  *= (const type)   : matrix

fn Eigen(const Matrix, Matrix, Matrix) : bool
fn Eigen(const Matrix, const Matrix, Matrix, Matrix, Matrix) : bool
fn LU(const Matrix, Matrix, Matrix) : bool
fn Cholesky(const Matrix, Matrix)   : bool
fn QR(const Matrix, Matrix, Matrix) : bool
fn FullQR(const Matrix, Matrix, Matrix) : bool
fn Schur(const Matrix, Matrix, Matrix) : bool
fn SVD(const Matrix, Matrix, Vector, Matrix) : bool
fn GSVD(const Matrix, const Matrix, Matrix, Matrix, Matrix) : bool
fn log(const Matrix, const type) : Matrix
fn exp(const Matrix, const type) : Matrix
fn pow(const Matrix, const type) : Matrix
fn pseudoInverse(const Matrix) : Matrix
fn feasible(const Matrix, const Vector) : bool
fn LP(const Matrix, const Vector, const Vector) : Vector
fn QP(const Matrix, const Vector, const Matrix, const Vector) : Vector
fn Fourier(const Vector, const bool) : Vector
# if vector size is prime, not fast one.
fn FastFourier(const Vector, const bool) : Vector
fn Diff(const Vector, const bool) : Vector
fn MotherWavelet(const Vector, const Vector, const bool) : Vector

type Complex[def type] : Object
  def complex : Complex[type]
  _real : type
  _imag : type
  zero  : static(type(0))
  fn ctor()   : void
  fn ctor(e0 : (type | const type), e1 : (type | const type) = zero) : void
  fn ctor(e  : (complex | const complex))  : void
  fn []  (const Int) : type
  fn !   () const    : bool
  fn ~   () const    : complex
  fn -   () const    : complex
  fn *   (const complex) const : complex
  fn **  (const complex) const : complex
  fn /   (const complex) const : complex
  fn !=  (const complex) const : bool
  fn &&  (const complex) const : bool
  fn ||  (const complex) const : bool
  fn =   (complex)       : complex
  fn =   (const complex) : complex
  fn +=  (const complex) : complex
  fn -=  (const complex) : complex
  fn /=  (const complex) : complex
  fn /=  (const type) : complex

fn abs(const Complex) : type
fn arg(const Complex) : type

type Quaternion[def type] : Object
  def quat : Quaternion[type]
  _r1 : type
  _r2 : type
  _r3 : type
  _r4 : type
  fn ctor() : void
  fn ctor(e : (type | const type)) : void
  fn ctor(e : (Complex[type] | const Complex[type]))       : void
  fn ctor((type | const type), (type | const type), (type | const type), (type | const type)) : void
  fn ctor((Complex[type] | const Complex[type]), (Complex[type] | const Complex[type])) : void
  fn []  (const Int) : type
  fn !   () const    : bool
  fn ~   () const    : quat
  fn -   () const    : quat
  fn *   (const quat) const : quat
  fn **  (const quat) const : quat
  fn /   (const quat) const : quat
  fn +   (const quat) const : quat
  fn -   (const quat) const : quat
  fn !=  (const quat) const : bool
  fn &&  (const quat) const : bool
  fn ||  (const quat) const : bool
  fn =   (quat)       : quat
  fn =   (const quat) : quat
  fn +=  (const quat) : quat
  fn -=  (const quat) : quat
  fn /=  (const type) : quat

type CayleyHamilton[def type, def base] : Object
  def ch : CayleyHamilton[base]
  _r1 : type
  _r2 : type
  fn ctor(e : (type | const type)) : void
  fn ctor(e : (CayleyHamilton[type] | const CayleyHamilton[type])) : void
  fn []  (const Int) : type
  fn !   () const    : bool
  fn ~   () const    : ch
  fn -   () const    : ch
  fn *   (const ch) const : ch
  fn **  (const ch) const : ch
  fn /   (const ch) const : ch
  fn !=  (const ch) const : bool
  fn &&  (const ch) const : bool
  fn ||  (const ch) const : bool
  fn =   (ch)       : ch
  fn =   (const ch) : ch
  fn +=  (const ch) : ch
  fn -=  (const ch) : ch
  fn /=  (const type) : ch

# Huge...

# Finite Element:
type FE[def type, fn delegate(const Vector, const Vector) : type] : Array[Vector]

fn countupVolume(in : Array[Array[type] ], cut : Array[type], size : Int) : Array[type]
fn countupLattice(in : Array[Array[type] ], cut : Array[type], size : Int) : Array[type]
fn generateNormalDist(size : Int) : Array[type]

