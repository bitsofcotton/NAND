load Meta.s
# 1d: vector, 2d: matrix, 3d: tensor, 4d: vector[tensor].

type Vector[def type, def index, def Array = Array] # Vector
  def vector : Vector[type, index]
  e : Array[type]
  ctor(const index, const type e0)
  ctor(initer(idx : index, entity : type) : void) : vector
  [] (const index)        : type
  [] (const index)  const : const type
  [] (const index, const index)        : vector
  [] (const index, const index)  const : const vector
  friend bool
  -  ()             const : vector
  *dot (const vector) const : type
  != (const vector) const : bool
  =  (vector)       : vector
  =  (const vector) : vector
  += (const vector) : vector
  -= (const vector) : vector
  *=  (const type)   : vector
  **= (const type)   : vector
  /=  (const type)   : vector
  %=  (const type)   : vector
  <   (const type)   : bool

type Matrix[def type, def index0, def Array = Array] # Matrix
  def matrix : Matrix[type, index0]
  def vector : Vector[type, index0]
  def index  : Complex[index0]
  _e : Array[vector]
  ctor(const index, const type e0) : void
  []row(const index0) : vector
  []row(const index0) const : const vector
  []setCol(const index0, const vector) : void
  []col(const index0) const : const vector
  [] (const index)       : type
  [] (const index) const : const type
  [] (const index, const index)       : type
  [] (const index, const index) const : const type
  !  ()             const : bool
  -  ()             const : matrix
  *  (const vector) const : vector
  *  (const matrix) const : matrix
  ** (const type)   const : matrix
  <d  (const matrix) const : bool
  != (const vector) const : bool
  =  (matrix)       : matrix
  =  (const matrix) : matrix
  += (const matrix) : matrix
  -= (const matrix) : matrix
  *= (const type)   : matrix

Eigen(const Matrix, Matrix, Matrix) : bool
Eigen(const Matrix, const Matrix, Matrix, Matrix, Matrix) : bool
LU(const Matrix, L: Matrix, U: Matrix) : bool
Cholesky(const Matrix, C: Matrix)   : bool
QR(const Matrix, Qt: Matrix, R: Matrix) : bool
Schur(const Matrix, U: Matrix, A: Matrix) : bool
SVD(const Matrix, Ut: Matrix, w: Vector, V: Matrix) : bool
SVD(A: const Matrix, B: const Matrix, Ut: Matrix, V0: Matrix, V1: Matrix) : bool
log(const Matrix) : Matrix
exp(const Matrix) : Matrix
pow(const Matrix, p: const type) : Matrix
pseudoInverse(const Matrix) : Matrix
feasible(A: const Matrix, b: const Vector, interior: Vector) : bool
LP(A: const Matrix, b: const Vector, c: const Vector) : Vector
QP(const Matrix, const Vector, const Matrix, const Vector) : Vector
Fourier(v: const Vector, inverse: const bool) : Vector
# if vector size is prime, not fast one.
FastFourier(v: const Vector, inverse: const bool) : Vector
Diff(v: const Vector, integrate: const bool) : Vector
MotherWavelet(const Vector, const Vector, const bool) : Vector

type Complex[def type] : Object # Complex plane point
  def complex : Complex[type]
  _real : type
  _imag : type
  zero  : static(type(0))
  ctor()
  ctor(e0 : (type | const type), e1 : (type | const type) = zero)
  ctor(e  : (complex | const complex))
  []  (const Int) : type
  !   () const    : bool
  ~   () const    : complex
  -   () const    : complex
  *   (const complex) const : complex
  **  (const complex) const : complex
  /   (const complex) const : complex
  !=  (const complex) const : bool
  &&  (const complex) const : bool
  ||  (const complex) const : bool
  =   (complex)       : complex
  =   (const complex) : complex
  +=  (const complex) : complex
  -=  (const complex) : complex
  /=  (const complex) : complex
  /=  (const type) : complex

abs(const Complex) : type
arg(const Complex) : type

type Quaternion[def type] : Object # Quarternion space point
  def quat : Quaternion[type]
  _r1 : type
  _r2 : type
  _r3 : type
  _r4 : type
  ctor()
  ctor(e : (type | const type))
  ctor(e : (Complex[type] | const Complex[type]))
  ctor((type | const type), (type | const type), (type | const type), (type | const type))
  ctor((Complex[type] | const Complex[type]), (Complex[type] | const Complex[type]))
  []  (const Int) : type
  !   () const    : bool
  ~   () const    : quat
  -   () const    : quat
  *   (const quat) const : quat
  **  (const quat) const : quat
  /   (const quat) const : quat
  +   (const quat) const : quat
  -   (const quat) const : quat
  !=  (const quat) const : bool
  &&  (const quat) const : bool
  ||  (const quat) const : bool
  =   (quat)       : quat
  =   (const quat) : quat
  +=  (const quat) : quat
  -=  (const quat) : quat
  /=  (const type) : quat

type CayleyHamilton[def type, def base] : Object # Cayley Dickson construction
  def ch : CayleyHamilton[base]
  _r1 : type
  _r2 : type
  ctor(e : (type | const type))
  ctor(e : (CayleyHamilton[type] | const CayleyHamilton[type]))
  []  (const Int) : type
  !   () const    : bool
  ~   () const    : ch
  -   () const    : ch
  *   (const ch) const : ch
  **  (const ch) const : ch
  /   (const ch) const : ch
  !=  (const ch) const : bool
  &&  (const ch) const : bool
  ||  (const ch) const : bool
  =   (ch)       : ch
  =   (const ch) : ch
  +=  (const ch) : ch
  -=  (const ch) : ch
  /=  (const type) : ch

# Huge...

# Finite Element:
type FE[def type, delegate(const Vector, const Vector) : type] : Array[Vector]

countupVolume(in : Array[Array[type] ], cut : Array[type], size : Int) : Array[type]
countupLattice(in : Array[Array[type] ], cut : Array[type], size : Int) : Array[type]
generateNormalDist(size : Int) : Array[type]

