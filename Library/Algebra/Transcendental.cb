grammer "default.xml"
require "Functions"

type bothside<def type, def f>(const type val, const type error, type left, type right)
{
  while(f(right) > val && right - left > error) {
    T mid(left + right);
    mid >>= 1;
    if(f(mid) < val)
      left  = mid;
    else
      right = mid;
  }
  return left;
}

type pi<def type>()
  // Arithmetic Geometric Mean algorithm.
  // from pi_fftc6 by T.Ooura
  // http://www.kurims.kyoto-u.ac.jp/~ooura/fft.html
  type c(sqrt(type(1) >> 3));
  type a(1);
  a += c;
  a += c << 1;
  
  type b(sqrt(a));
  type e(b - ((type(1) >> 1) + (type(1) >> 3)));
  b <<= 1;
  c = e - c;
  a += e;
  
  // fixme
  integer npow(2);
  type epsilon(sqrt(sqrt(error)));
  do {
    npow ++;
    e = (a + b) >> 1;
    b = sqrt(a * b);
    e = e - b;
    b <<= 1;
    c = c - e;
    a = e + b;
  } while (e > epsilon);
  e *= e;
  e >>= 2;
  a += b;
  return ((a * a - e - (e >> 1)) / (a * c - e)) >> npow;
end

type sin<def type>(const type s)
  // normalization.
  if(s < - pi<T>())
    s += floor(s / pi<T>()) * pi<T>();
  else if(pi<T>() < s)
    s -= floor(s / pi<T>()) * pi<T>();
  
  T result(s);
  T num(s * s * s);
  T denom(- 2 * 3);
  T count(4);
  while(!!(num / denom)) {
    result += num / denom;
    num    *= s * s;
    denom  *= - count * (count + 1);
    count  += 2;
  }
  return result;
end

